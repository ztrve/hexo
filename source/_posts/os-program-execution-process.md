---
title: CPU工作原理-操作系统(一)  
tags: CPU  
date: 2021/6/15  
categories:
- 操作系统
- CPU
keywords: [CPU,程序,运行过程,操作系统]   
description: CPU运行过程-操作系统(一)
---
CPU 和内存是一个计算机的核心. 本节以程序运行的角度来解释 CPU 的工作原理.    

<!-- more -->
# 操作系统
Operate System: 计算机操作系统起到一个承上启下的作用, 上层对接应用层软件, 下层对接计算机硬件. 操作系统为开发者们提供了用户态、内核态的接口, 让计算机开发人员在这些基础上开发应用. JVM (Java 虚拟机: Java Virtual Machine) 本质上也是一种应用程序, 设计原理也跟操作系统很像, 编译器将 *.java 文件编译成 Byte Code, JVM 将二进制码翻译成一条条计算机指令交给操作系统执行. 本节也是为了之后更好的学习 JVM 级别的原理, 先学习操作系统相关的基础知识.
# CPU的概念
CPU: 中央处理器(Central Processing Unit). 计算机系统的运算和控制核心, 是信息处理、程序运行的最终执行单元
# CPU的组成
![CPU架构](cpu-struct.png)

- `ALU: `算术逻辑单元(Arithmetic&Logical Unit). 从 Registers 中读取数据, 从 PC 中获取计算指令, 接受时钟发生器的电信号后, 才能实现计算. 并将计算后的结果, 写回寄存器  
- `Registers: `寄存器. 作用是存放数据, 不论是 CPU 计算所需要用到的数据, 还是计算完成后需要写回内存的数据. 寄存器的种类非常多, 例如: AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW. 这些仅仅是 8086CPU 中一些常见的寄存器. 而现在一般寄存器数量会在数百个.
- `PC: ` 程序计数器(Program Counter). 存放下一条指令的地址. CPU 在运算时光有数据是不够的, 还需要一些运算逻辑, 这些就是指令. 指令的物理地址其实在内存中的固定位置, 这里存放的只是指令的地址. 
- `Cache: `缓存. 单核 CPU 中一般存在两级缓存. 多核 CPU 中存在三级缓存. 按照数据读取的顺序或离 ALU 的远近称他们为一级缓存、二级缓存、三级缓存. 缓存的效率都是不等的, 其中一级缓存的性能最好. 学过 Java Volatile 关键字的同学对这个应该不陌生
- `CU: `控制单元(Control Unit). 由三部分组成: 指令寄存器 IR(Instruction Register)、指令译码器 ID(Instruction Decoder) 和操作控制器 OC(Operation Controller), 用户输入指令地址后, 会存储在 PC 中, 当计算机要执行计算时, 会事先将数据加载到 ALU 中. CU 中的 ID 会将指令地址翻译成对应的指令, 放到 IR 中, 这时候 OC 中的发生器会释放电信号, 推动 ALU 计算.  
- `MMU: `内存管理单元(Memory Management Unit). 将 OS 提供的虚拟内存地址转换为物理地址. 在古老的 DOS 时代, 是由用户直接管理物理内存地址的, 导致某个程序一旦奔溃, 会引发整台机器的瘫痪. 现在在操作系统的加持下, 所有用户拿到的都是虚拟地址, 真实的物理地址由内核态(Kernel) 管理, 这样一些重要的内存普通用户就无法操作了, 保证了操作系统的安全稳定, 也为用户提供了隔离的内存环境.

# 计算机主要硬件分布
计算机上有许多硬件: CPU、内存、USB、显卡等, 它们由不同的总线(Bus) 相连. 
- 计算最强的 CPU 和存储最快的 Memory 之间由北桥芯片连接
- 北桥芯片也是专门用来处理那些 IO 较快的数据, 最典型的例子就是 CPU 与 内存之间的交互. 
- 南桥芯片, 用于接收那些 IO 没那么快的数据, 如键盘、音频、网卡、显卡等硬件输入
- 为什么要区分南桥北桥呢? 因为, 南桥的 IO 较慢, 如果只有一根总线来接受所有数据, 那么当低速的 IO 占用总线的时候, 势必会阻塞高速的 IO  
![计算机硬件架构](hardware-structure.png)


# 应用程序启动运行
了解计算机主要硬件之间的分布关系后, 我们举个启动微信的例子, 方便理解应用程序是如何启动运行的.  
- 在处理界面点击 Wechat.exe 
- 操作系统会通知磁盘, 让它将 Wechat 对应的数据读取出来
- Wechat 的数据通过 IO 总线传递给南桥芯片
- 通过内存总线将写入内存
- 程序初始化的一些命令及数据通过内存总线传递给北桥芯片
- 北桥芯片再将这些命令及数据通过系统总线中的数据总线、控制总线、地址总线传递给 CPU 的缓存
- CPU 缓存再经历三级、二级、一级缓存
- 将指令传递给 PC, 数据传递给 Registers
- ALU 从 PC 中获取指令, 从 Registers 中获取数据后进行运算
- ALU 将运算结果放到 Registers 中
- Registers 再将数据通过一级、二级、三级缓存系统总线、北桥芯片、内存总线, 将数据写回内存
- 所有指令处理完毕, 应用程序也就启动了

# 硬件中断的过程
硬件中断是由硬件发起的中断请求(IRQ). 这是一个异步信号, 表明需要注意或需要改变在执行一个同步事件. 硬件中断是由与系统相连的外设(比如网卡 硬盘 键盘等)自动产生的. 每个设备或设备集都有他自己的中断请求(IRQ).   
当 IO 总线上的硬件设备发起 IRQ 后, 过程基本如下: 
- 硬件发起 IRQ
- IRQ 经过 IO 总线、南桥芯片、PCI 总线、北桥芯片、系统总线. 将中断信号传递给CPU
- CPU 中正在执行的指令被中断并挂起
- CU 解析中断信号并将对应数据及指令交给 CPU 处理
- CPU 处理完后, 将处理结果交给操作系统内核 Kernel
- Kernel 通知对应的应用程序处理中断信息

# 软件中断的过程
软件中断则是由应用程序发起的中断请求, c 语言调用 int(errupt) 0x80H(H 指 16进制 Hex) 或 sysenter 源语将调用号填入 ax 寄存器. 参数通过 bx cx dx si di 传入内核返回值通过 ax 返回.    
这里以 Java 读取网络 IO 来举例:  
- Java 读取网络 IO
- JVM 调用 read()
- c 库 read()
- 内核态调用 int 0x80 或 sysenter 系统源语
- 通过系统总线将数据、指令、地址传递给 CPU
- CPU 从 ax 寄存器中获取调用号
- 从 bx cx dx si di 寄存器中获取参数并计算(拉取网络 IO)
- 计算结果放回 ax 寄存器
- 传回内核态
- 传回 JVM